
#+property: header-args:cpp :flags -std=c++20 -I ../repo/yliss/include -ldl -lGL -lglfw ../repo/yliss/src/glad.c :eval never :main no :exports both :noweb no-export

* Prelude

** Inclusion

General include script:
#+name: include
#+begin_src sh :var args="" :results output :wrap "src cpp" :eval no-export :dir ../repo/yliss
./litlib/include.pl "window.org litlib/cpp.org graphics.org ../../draw/imgen.org" "$args"
#+end_src

Specialised block for shaders (makes things slightly more readable):
#+name: shd
#+begin_src bash :var noweb="" sources="imgen.org" :results output :wrap "src text" :eval no-export
../repo/litlib/include.pl "$sources" ":noweb $noweb :c-string"
#+end_src

** C++ image generation tools

*** =square_writer=

Creates an image writer able to construct a square crop of the given size.
#+name: square_writer
#+begin_src cpp
template<int JpegQuality>
auto square_writer(GLsizei pixels) {
    using namespace compose;
    using namespace image;
    using namespace image::format;
    return typename deduce<JpegQuality>::writer(square_crop{} | resize{pixels, pixels});
}
#+end_src
#+depends:square_writer :noweb compose image/square_crop image/resize image/format/deduce

*** =screenshot=

The =screenshot= function used in renders one frame in the given window, takes a screenshot of the rendering, saves it and returns.
#+name: screenshot
#+begin_src cpp
template<class Render, class ImageWriter>
void screenshot(
    const lazy_window& lazy, std::string_view destination,
    const ImageWriter& writer, Render render
) {
    lazy.render_n(1, render);
    writer(lazy, destination);
    std::cout << "[[file:" << destination << "]]\n";
}
#+end_src
#+depends:screenshot :noweb lazy_window :cpp iostream string_view

*** =imgspec=

Gathers all the information needed to generate an image, with reasonable defaults for the vertex and fragment shaders.

#+name: imgspec
#+begin_src cpp
struct imgspec {
    const char *vs =
        "#version 330 core\n"
        "layout (location = 0) in vec3 position;\n"
        "layout (location = 1) in vec3 color_in;\n"
        "out vec3 color_fs;\n"
        "\n"
        "uniform mat4 model;\n"
        "uniform mat4 view;\n"
        "uniform mat4 projection;\n"
        "\n"
        "void main() {\n"
        "    gl_Position = projection * view * model * vec4(position, 1.0f);\n"
        "    color_fs = color_in;\n"
        "}\n";
    const char *fs =
        "#version 330 core\n"
        "out vec4 color_out;\n"
        "in vec3 color_fs;\n"
        "\n"
        "void main() {\n"
        "    color_out = vec4(color_fs, 1.);\n"
        "}\n";
    const std::vector<float>& vtx;
    const std::vector<unsigned int>& layout;
    const std::vector<unsigned int>& idx;

    <<imgspec/public>>
};
#+end_src
#+depends:imgspec :noweb lazy_window shader_program VAO vertices indexes movipr transform screenshot square_writer :cpp vector string_view

The =gen= method can generate an image under the given path by opening a window and rendering one frame using the information contained in the =imgspec=.

#+begin_src cpp :eval no-export :exports both :noweb-ref imgspec/public
void gen(std::string_view destination) {
    lazy_window lazy("image generation", 640u, 480u);
    shader_program shader{vertex_shader(vs), fragment_shader(fs)};
    VAO vao{};
    vertices<GLfloat> vtxobj(vtx, layout);
    indexes idxobj(idx);
    movipr viper(
        transform(),
        transform().translate({0, 0, -3}),
        {.aspect = lazy.aspect()},
        shader
    );

    auto render = [&]{
        shader.use();
        vao.bind();
        idxobj.draw();
    };
    screenshot(lazy, destination, square_writer<90>(720), render);
}
#+end_src



*** Usage

#+begin_src cpp :eval no-export :exports both :tangle debug.cpp
<<include(":noweb imgspec")>>

int main() {
    imgspec{
        .vtx = { // Positions    // Colors
                    .5,  .5,  .5,   1, 1, 0,  // Yellow.
                   -.5,  .5,  .5,   1, 0, 1,  // Magenta.
                    .5,  .5, -.5,   1, 1, 1,  // White.
                   -.5,  .5, -.5,   0, 1, 1,  // Cyan.
                    .5, -.5,  .5,   0, 1, 1,  // Cyan.
                   -.5, -.5,  .5,   1, 1, 1,  // White.
                   -.5, -.5, -.5,   1, 1, 0,  // Yellow.
                    .5, -.5, -.5,   1, 0, 1}, // Magenta.
        .layout = {3, 3},
        .idx = { 3, 2, 6,
                 2, 6, 7,
                 6, 7, 4,
                 7, 4, 2,
                 4, 2, 0,
                 2, 0, 3,
                 0, 3, 1,
                 3, 1, 6,
                 1, 6, 5,
                 6, 5, 4,
                 5, 4, 1,
                 4, 1, 0 }
    }.gen("usage.png");

    return 0;
}
#+end_src

#+RESULTS:
:results:
[[file:usage.png]]
:end:
